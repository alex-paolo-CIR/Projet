#include "Avion.hpp"
#include <sstream>
#include <cmath>
#include <map>

using namespace std;

// definition constantes
const float Avion::TEMPS_TRAME = 0.016f;
const float Avion::TEMPS_PARKING = 8.0f;
const float Avion::INTERVALLE_VERIFICATION_ATTENTE = 0.5f;

Avion::Avion(int id, TourControle* tour, Position posDepart, float vitesse)
    : id_(id)
    , tour_(tour)
    , position_(posDepart)
    , positionCible_(posDepart)
    , angleRotation_(0.0f)
    , vitesse_(vitesse)
    , vitesseBase_(vitesse)
    , angleAttente_(0.0f)
    , etat_(EtatAvion::APPROCHE)
    , actif_(true)
    , enCours_(false)
    , carburant_(ConfigCarburant::CARBURANT_MAX)
    , aDemandePiste_(false)
    , parkingAssigne_(-1)
{
    stringstream ss;
    ss << "avion " << id_ << " cree position (" 
       << position_.x << ", " << position_.y << ") carburant " << carburant_.load();
    Journaliseur::obtenirInstance().journaliser("Avion", ss.str(), "INFO");
}

Avion::~Avion() {
    arreter();
    if (thread_ && thread_->joinable()) {
        thread_->join();
    }
}

void Avion::demarrer() {
enCours_ = true;
  thread_ = make_unique<thread>(&Avion::lancer, this);
    
    stringstream ss;
  ss << "avion " << id_ << " thread demarre";
    Journaliseur::obtenirInstance().journaliser("Avion", ss.str(), "INFO");
}

void Avion::arreter() {
    enCours_ = false;
    actif_ = false;
}

void Avion::rejoindre() {
    if (thread_ && thread_->joinable()) {
   thread_->join();
    }
}

Position Avion::obtenirPosition() const {
    lock_guard<mutex> verrou(mutexPosition_);
    return position_;
}

float Avion::obtenirAngleRotation() const {
    lock_guard<mutex> verrou(mutexRotation_);
    return angleRotation_;
}

void Avion::marquerCommeEcrase() {
    mettreAJourEtat(EtatAvion::ECRASE);
    actif_ = false;
}

void Avion::lancer() {
    while (enCours_.load() && actif_.load()) {
 EtatAvion etatActuel = etat_.load();
      
        // maj carburant sauf parking et crash
  if (etatActuel != EtatAvion::STATIONNE && etatActuel != EtatAvion::ECRASE) {
     mettreAJourCarburant(TEMPS_TRAME);
     }
     
 // verif carburant prioritaire
   verifierStatutCarburant();
    
        // si crash arreter immediatement
        if (etat_.load() == EtatAvion::ECRASE) {
     phaseEcrase();
      break;
}
        
   // machine a etats sans sleep inutiles
        switch (etatActuel) {
  case EtatAvion::APPROCHE:
   phaseApproche();
 break;
   case EtatAvion::ATTENTE:
    phaseAttente();
break;
        case EtatAvion::ATTERRISSAGE:
     phaseAtterrissage();
      break;
        case EtatAvion::ATTENTE_CROISEMENT:
       phaseAttenteCroisement();
            break;
        case EtatAvion::CROISEMENT:
      phaseCroisement();
   break;
  case EtatAvion::ROULAGE_ENTREE:
   phaseRoulageEntree();
         break;
  case EtatAvion::STATIONNE:
            phaseStationnement();
    break;
     case EtatAvion::ROULAGE_SORTIE:
      phaseRoulageSortie();
      break;
        case EtatAvion::DECOLLAGE:
            phaseDecollage();
   break;
        case EtatAvion::DEPART:
            phaseDepart();
break;
  case EtatAvion::URGENCE:
       phaseUrgence();
     break;
 case EtatAvion::PARTI:
          actif_ = false;
 break;
 default:
  break;
      }
 
        // seul sleep boucle physique 60 fps
     this_thread::sleep_for(chrono::milliseconds((int)(TEMPS_TRAME * 1000)));
    }
    
    stringstream ss;
ss << "avion " << id_ << " thread termine";
    Journaliseur::obtenirInstance().journaliser("Avion", ss.str(), "INFO");
}

void Avion::mettreAJourCarburant(float dt) {
    float carburantActuel = carburant_.load();
    carburantActuel -= ConfigCarburant::TAUX_CONSOMMATION_CARBURANT * dt;
    
    if (carburantActuel < 0.0f) {
     carburantActuel = 0.0f;
    }
    
    carburant_ = carburantActuel;
}

void Avion::ravitaillerAuParking(float dt) {
 float carburantActuel = carburant_.load();
    carburantActuel += ConfigCarburant::TAUX_REMPLISSAGE_CARBURANT * dt;
    
    if (carburantActuel > ConfigCarburant::CARBURANT_MAX) {
        carburantActuel = ConfigCarburant::CARBURANT_MAX;
    }
    
    carburant_ = carburantActuel;
}

void Avion::verifierStatutCarburant() {
    float carburantActuel = carburant_.load();
    EtatAvion etatActuel = etat_.load();
    
    // crash immediat si plus de carburant
    if (carburantActuel <= 0.0f && etatActuel != EtatAvion::ECRASE) {
  stringstream ss;
        ss << "avion " << id_ << " crash plus de carburant position (" 
           << position_.x << ", " << position_.y << ")";
        Journaliseur::obtenirInstance().journaliser("Avion", ss.str(), "ERROR");
 marquerCommeEcrase();
   return;
    }
    
    // urgence si carburant bas
    if (carburantActuel < ConfigCarburant::SEUIL_URGENCE_CARBURANT && 
        etatActuel != EtatAvion::URGENCE &&
        etatActuel != EtatAvion::ECRASE &&
        etatActuel != EtatAvion::STATIONNE) {
  
        stringstream ss;
    ss << "avion " << id_ << " urgence carburant bas " << carburantActuel;
        Journaliseur::obtenirInstance().journaliser("Avion", ss.str(), "WARN");
 mettreAJourEtat(EtatAvion::URGENCE);
    }
}

void Avion::phaseApproche() {
    positionCible_ = tour_->obtenirPointApproche();
deplacerVers(positionCible_, TEMPS_TRAME);
  
    if (aCibleAtteinte(positionCible_)) {
     // demande piste GAUCHE pour atterrissage
 bool estUrgence = carburant_.load() < ConfigCarburant::SEUIL_URGENCE_CARBURANT;
        if (tour_->demanderPisteGauche(id_, estUrgence)) {
          // transition immediate vers atterrissage
 mise
